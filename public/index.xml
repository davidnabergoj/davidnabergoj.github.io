<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sunny Coding</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Sunny Coding</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en</language>
    <copyright>2025 - David Nabergoj</copyright>
    <lastBuildDate>Wed, 03 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 2542: Maximum Subsequence Score</title>
      <link>http://localhost:1313/posts/leetcode_2542/</link>
      <pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_2542/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll be solving &lt;a href=&#34;https://leetcode.com/problems/maximum-subsequence-score&#34;&gt;LeetCode problem 2542&lt;/a&gt;.
We have two integer arrays &lt;code&gt;nums1&lt;/code&gt; and &lt;code&gt;nums2&lt;/code&gt; with size \(n\), as well as an integer \(k\).
Let&amp;rsquo;s denote &lt;code&gt;nums1&lt;/code&gt; with \(A\) and &lt;code&gt;nums2&lt;/code&gt; with \(B\).
If we pick a set of indices \(S\) with exactly \(k\) elements, we obtain a score as follows:
&lt;/p&gt;
\[
    \min \left\{ B_i | i \in S \right\} \sum_{i \in S} A_i
\]&lt;p&gt;
There are many different sets \(S\) that give different scores.
We want to find the maximum possible score.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2336: smallest number in infinite set</title>
      <link>http://localhost:1313/posts/leetcode_2236/</link>
      <pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_2236/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll be solving &lt;a href=&#34;https://leetcode.com/problems/smallest-number-in-infinite-set&#34;&gt;LeetCode problem 2236&lt;/a&gt;.
We start with an infinite set containing all positive integers.
We may remove and return the smallest integer using &lt;code&gt;int popSmallest()&lt;/code&gt; or add a positive integer back into the set using &lt;code&gt;void addBack(int num)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;strategy&#34;&gt;Strategy&lt;/h2&gt;
&lt;p&gt;If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable &lt;code&gt;n&lt;/code&gt;.
We start with &lt;code&gt;n = 1&lt;/code&gt;.
Each time we pop, we increment &lt;code&gt;n&lt;/code&gt; by one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Trie implementation</title>
      <link>http://localhost:1313/posts/leetcode_208/</link>
      <pubDate>Sun, 30 Nov 2025 13:45:28 +0100</pubDate>
      <guid>http://localhost:1313/posts/leetcode_208/</guid>
      <description>&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Trie&#34;&gt;trie&lt;/a&gt; is data structure which holds strings.
It allows fast search and insertion of strings, as well as fast search of string prefixes.
This can be especially useful for text autocompletion and spellcheck.&lt;/p&gt;
&lt;p&gt;In this post, we implement a trie in C++ with three basic operations: &lt;code&gt;search&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, and &lt;code&gt;startsWith&lt;/code&gt;.
This is the solution to &lt;a href=&#34;https://leetcode.com/problems/implement-trie-prefix-tree/description/&#34;&gt;LeetCode 208&lt;/a&gt;.
The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.&lt;/p&gt;</description>
    </item>
    <item>
      <title>About Me</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Sat, 29 Nov 2025 12:00:00 +0000</pubDate>
      <guid>http://localhost:1313/about/</guid>
      <description>&lt;p&gt;&lt;img alt=&#34;David&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/david.jpg#avatar&#34;&gt;&lt;/p&gt;
&lt;p&gt;Hi! I&amp;rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.
I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.
For the last four years, I&amp;rsquo;ve also been a TA for postgraduate probability and statistics courses.
I do a lot of research on normalizing flows, a special family of generative models.
I use flows to speed up MCMC by transforming difficult data spaces into simple ones.
I&amp;rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.
I&amp;rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.
I&amp;rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
