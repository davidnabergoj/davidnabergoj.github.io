<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>C&#43;&#43; on Sunny Coding</title>
    <link>http://localhost:1313/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Sunny Coding</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en</language>
    <copyright>2025 - David Nabergoj</copyright>
    <lastBuildDate>Wed, 31 Dec 2025 10:00:00 +0100</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 189: Rotate Array</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_189/</link>
      <pubDate>Wed, 31 Dec 2025 10:00:00 +0100</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_189/</guid>
      <description>&lt;p&gt;Happy new year! ðŸ¥³ðŸŽ‰ðŸŽ‰ðŸŽ‰ Let&amp;rsquo;s make 2026 awesome!&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s solve &lt;a href=&#34;https://leetcode.com/problems/rotate-array&#34;&gt;LeetCode problem 189: Rotate Array&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt;, rotate the array to the right by \(k\) steps, where \(k\) is non-negative.&lt;/p&gt;
&lt;p&gt;Constraints:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= k &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;This problem is fairly straightforward. I&amp;rsquo;ll present three solutions in C++.
Let&amp;rsquo;s dive in!&lt;/p&gt;
&lt;p&gt;Note: rotations have a sort of cyclical property. If \(k\) is greater or equal to \(n\) (the length of &lt;code&gt;nums&lt;/code&gt;), then rotating &lt;code&gt;nums&lt;/code&gt; by with \(k\) is the same as rotating it with \(k\) modulo \(n\) &amp;ndash; the remainder after dividing \(k\) by \(n\).
We will always work with the remainder instead of the original \(k\).&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 80: Remove Duplicates from Sorted Array II</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_80/</link>
      <pubDate>Tue, 30 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_80/</guid>
      <description>&lt;p&gt;Today, let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii&#34;&gt;LeetCode problem 80: Remove Duplicates from Sorted Array II&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an integer array &lt;code&gt;nums&lt;/code&gt; sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.&lt;/p&gt;
&lt;p&gt;Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array &lt;code&gt;nums&lt;/code&gt;. More formally, if there are \(k\) elements after removing the duplicates, then the first \(k\) elements of &lt;code&gt;nums&lt;/code&gt; should hold the final result. It does not matter what you leave beyond the first \(k\) elements.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 2462: Total Cost to Hire K Workers</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_2462/</link>
      <pubDate>Mon, 29 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_2462/</guid>
      <description>&lt;p&gt;Today, let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/total-cost-to-hire-k-workers/&#34;&gt;LeetCode problem 2462: Total Cost to Hire K Workers&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given a 0-indexed integer array &lt;code&gt;costs&lt;/code&gt; where &lt;code&gt;costs[i]&lt;/code&gt; is the cost of hiring the \(i\)-th worker.
You are also given two integers \(k\) and &lt;code&gt;candidates&lt;/code&gt;. We want to hire exactly \(k\) workers according to the following rules:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You will run \(k\) sessions and hire exactly one worker in each session.&lt;/li&gt;
&lt;li&gt;In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.
&lt;ul&gt;
&lt;li&gt;For example, if &lt;code&gt;costs = [3,2,7,7,1,2]&lt;/code&gt; and &lt;code&gt;candidates = 2&lt;/code&gt;, then in the first hiring session, we will choose the 4th worker because they have the lowest cost &lt;code&gt;[3,2,7,7,**1**,2]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index &lt;code&gt;[3,**2**,7,7,2]&lt;/code&gt;. Please note that the indexing may be changed in the process.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.&lt;/li&gt;
&lt;li&gt;A worker can only be chosen once.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Return the total cost to hire exactly \(k\) workers.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 88: Merge Sorted Array</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_88/</link>
      <pubDate>Mon, 29 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_88/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s solve &lt;a href=&#34;https://leetcode.com/problems/merge-sorted-array/&#34;&gt;LeetCode problem 88: Merge Sorted Array&lt;/a&gt;.
This problem is quite short and straightforward.&lt;/p&gt;
&lt;p&gt;The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given two integer arrays &lt;code&gt;nums1&lt;/code&gt; and &lt;code&gt;nums2&lt;/code&gt;, sorted in non-decreasing order, and two integers \(m\) and \(n\), representing the number of elements in &lt;code&gt;nums1&lt;/code&gt; and &lt;code&gt;nums2&lt;/code&gt; respectively.
Merge &lt;code&gt;nums1&lt;/code&gt; and &lt;code&gt;nums2&lt;/code&gt; into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array &lt;code&gt;nums1&lt;/code&gt;. To accommodate this, &lt;code&gt;nums1&lt;/code&gt; has a length of \(m\) + \(n\), where the first \(m\) elements denote the elements that should be merged, and the last \(n\) elements are set to 0 and should be ignored. &lt;code&gt;nums2&lt;/code&gt; has a length of \(n\).&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 216: Combination Sum III</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_216/</link>
      <pubDate>Sun, 28 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_216/</guid>
      <description>&lt;p&gt;Today, let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/combination-sum-iii&#34;&gt;LeetCode problem 216: Combination Sum III&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Find all valid combinations of \(k\) numbers that sum up to \(n\) such that the following conditions are true:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Only numbers 1 through 9 are used.&lt;/li&gt;
&lt;li&gt;Each number is used at most once.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 790: Domino and Tromino Tiling</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_790/</link>
      <pubDate>Sun, 28 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_790/</guid>
      <description>&lt;p&gt;Today, let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/domino-and-tromino-tiling&#34;&gt;LeetCode problem 790: Domino and Tromino Tiling&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You have two types of tiles: a &lt;code&gt;2 x 1&lt;/code&gt; domino shape and a tromino shape. You may rotate these shapes.
Given an integer \(n\), return the number of ways to tile an &lt;code&gt;2 x n&lt;/code&gt; board. Since the answer may be very large, return it modulo &lt;code&gt;10^9 + 7&lt;/code&gt;.
In a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 875: Koko Eating Bananas</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_875/</link>
      <pubDate>Sun, 28 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_875/</guid>
      <description>&lt;p&gt;Today, let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/koko-eating-bananas&#34;&gt;LeetCode problem 875: Koko Eating Bananas&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Koko loves to eat bananas. There are &lt;code&gt;n&lt;/code&gt; piles of bananas, the \(i\)-th pile has &lt;code&gt;piles[i]&lt;/code&gt; bananas.
The guards have gone and will come back in &lt;code&gt;h&lt;/code&gt; hours.
Koko can decide her bananas-per-hour eating speed of &lt;code&gt;k&lt;/code&gt;.
Each hour, she chooses some pile of bananas and eats &lt;code&gt;k&lt;/code&gt; bananas from that pile.
If the pile has less than &lt;code&gt;k&lt;/code&gt; bananas, she eats all of them instead and will not eat any more bananas during this hour.
Koko likes to eat slowly but still wants to finish eating all the bananas before the guards return.
Return the minimum integer &lt;code&gt;k&lt;/code&gt; such that she can eat all the bananas within &lt;code&gt;h&lt;/code&gt; hours.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 72: Edit distance</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_72/</link>
      <pubDate>Sat, 27 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_72/</guid>
      <description>&lt;p&gt;Today, let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/edit-distance&#34;&gt;LeetCode problem 72: Edit distance&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given two strings &lt;code&gt;word1&lt;/code&gt; and &lt;code&gt;word2&lt;/code&gt;, return the minimum number of operations required to convert &lt;code&gt;word1&lt;/code&gt; to &lt;code&gt;word2&lt;/code&gt;. You have the following three operations permitted on a word:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Insert a character&lt;/li&gt;
&lt;li&gt;Delete a character&lt;/li&gt;
&lt;li&gt;Replace a character&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let&amp;rsquo;s dive in!&lt;/p&gt;
&lt;h2 id=&#34;the-wagner-fischer-algorithm&#34;&gt;The Wagner-Fischer algorithm&lt;/h2&gt;
&lt;p&gt;There are several types of &lt;a href=&#34;https://en.wikipedia.org/wiki/Edit_distance&#34;&gt;edit distance&lt;/a&gt;.
This LeetCode problem defines it as the &lt;a href=&#34;https://en.wikipedia.org/wiki/Levenshtein_distance&#34;&gt;Levenshtein distance&lt;/a&gt;.
The most common algorithm to compute it is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Wagner%E2%80%93Fischer_algorithm&#34;&gt;Wagner-Fischer algorithm&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 746: Min Cost Climbing Stairs</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_746/</link>
      <pubDate>Sat, 27 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_746/</guid>
      <description>&lt;p&gt;Today, let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/min-cost-climbing-stairs&#34;&gt;LeetCode problem 746: Min Cost Climbing Stairs&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You are given an integer array &lt;code&gt;cost&lt;/code&gt; where &lt;code&gt;cost[i]&lt;/code&gt; is the cost of \(i\)-th step on a staircase. Once you pay the cost, you can either climb one or two steps.
You can either start from the step with index 0, or the step with index 1.
Return the minimum cost to reach the top of the floor.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 435: Non-overlapping Intervals</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_435/</link>
      <pubDate>Fri, 26 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_435/</guid>
      <description>&lt;p&gt;Today, let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/non-overlapping-intervals&#34;&gt;LeetCode problem 435: Non-overlapping intervals&lt;/a&gt;.
The instructions are as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an array of intervals intervals where &lt;code&gt;intervals[i] = [start_i, end_i]&lt;/code&gt;, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
Note that intervals which only touch at a point are non-overlapping. For example, &lt;code&gt;[1, 2]&lt;/code&gt; and &lt;code&gt;[2, 3]&lt;/code&gt; are non-overlapping.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let&amp;rsquo;s dive in!&lt;/p&gt;
&lt;h2 id=&#34;interval-scheduling-reformulation&#34;&gt;Interval scheduling reformulation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Interval_scheduling&#34;&gt;Interval scheduling&lt;/a&gt; is a class of problems that involve a set of tasks, represented by their start and end times.
The &lt;em&gt;interval scheduling maximization problem&lt;/em&gt; (ISMP) is about finding the largest set of non-overlapping tasks.
This is highly related to our interval removal problem.
In fact, the following statements are equivalent:&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 399: Evaluate Division</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_399/</link>
      <pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_399/</guid>
      <description>&lt;p&gt;Hi, everyone! Today, we&amp;rsquo;ll be looking at &lt;a href=&#34;https://leetcode.com/problems/evaluate-division/?envType=study-plan-v2&amp;amp;envId=leetcode-75&#34;&gt;LeetCode problem 399&lt;/a&gt;.
In this problem, we are given a bunch of reference equations of the form \(a_i / b_i = c_i\) for \(i = 1 , \dots, n\).
The symbols \(a_i, b_i\) are given as strings, while \(c_i\) are given as floating point numbers.
We&amp;rsquo;re then asked to compute the value of a &lt;em&gt;query&lt;/em&gt; equation \(q_1 / q_2\).&lt;/p&gt;
&lt;p&gt;If \(q_1 / q_2\) is one of the reference equations, we can return that value.
Otherwise, we can follow a kind of &lt;em&gt;chain-rule&lt;/em&gt; strategy.
Suppose we are given &lt;code&gt;&amp;quot;a&amp;quot; / &amp;quot;b&amp;quot;&lt;/code&gt; with value &lt;code&gt;2.0&lt;/code&gt; and &lt;code&gt;&amp;quot;b&amp;quot; / &amp;quot;c&amp;quot;&lt;/code&gt; with value &lt;code&gt;3.0&lt;/code&gt;, then we can compute &lt;code&gt;&amp;quot;a&amp;quot; / &amp;quot;c&amp;quot;&lt;/code&gt; by the product:
&lt;code&gt;&amp;quot;a&amp;quot; / &amp;quot;c&amp;quot; = &amp;quot;a&amp;quot; / &amp;quot;b&amp;quot; * &amp;quot;b&amp;quot; / &amp;quot;c&amp;quot;&lt;/code&gt;, which is equal to &lt;code&gt;2.0 * 3.0 = 6.0&lt;/code&gt;.
If there&amp;rsquo;s no way to find a solution, we return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 162: Find Peak Element</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_162/</link>
      <pubDate>Sun, 14 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_162/</guid>
      <description>&lt;p&gt;Very quick post about finding the peak element in an array.
This is &lt;a href=&#34;https://leetcode.com/problems/find-peak-element&#34;&gt;LeetCode problem 162&lt;/a&gt;.
We have an array &lt;code&gt;nums&lt;/code&gt; with \(n\) integers and want to find the index of one of its peaks in \(O(\log n)\) time.
The important detail is this: no two neighboring elements have the same value.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s dive in!&lt;/p&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;p&gt;To solve this in logarithmic time, we will use binary search.
We start with a &lt;code&gt;left&lt;/code&gt; index and a &lt;code&gt;right&lt;/code&gt; index.
We then compute a mid point &lt;code&gt;mid = (left + right) / 2&lt;/code&gt;.
Now we investigate what the local behavior around &lt;code&gt;mid&lt;/code&gt; is.
If &lt;code&gt;nums[mid] &amp;gt; nums[mid + 1]&lt;/code&gt;, it means that there&amp;rsquo;s no point searching for the peak at &lt;code&gt;mid + 1&lt;/code&gt; or to its right, so we set &lt;code&gt;right = mid&lt;/code&gt;.
Otherwise, there&amp;rsquo;s no point in searching for the peak at &lt;code&gt;mid&lt;/code&gt; or to its left, so we set &lt;code&gt;left = mid + 1&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 714: Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_714/</link>
      <pubDate>Sun, 14 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_714/</guid>
      <description>&lt;p&gt;Welcome back to another LeetCode walkthrough! Let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/&#34;&gt;LeetCode problem 714&lt;/a&gt;.
We&amp;rsquo;re given an array of stock prices. Each day, we can either buy a stock if we have none or sell a stock we own (but not both).
When we sell a stock, we have to pay a transaction fee.
We want to find the maximum profit we can achieve.&lt;/p&gt;
&lt;p&gt;We approach this using dynamic programming.
Let&amp;rsquo;s dive in!&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 1268: Search Suggestions System</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_1268/</link>
      <pubDate>Sat, 13 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_1268/</guid>
      <description>&lt;p&gt;Welcome back to another LeetCode walkthrough! This time, we&amp;rsquo;ll be tackling &lt;a href=&#34;https://leetcode.com/problems/search-suggestions-system&#34;&gt;LeetCode problem 1268&lt;/a&gt;.
We&amp;rsquo;re given an array of strings called &lt;code&gt;products&lt;/code&gt;, as well as a string &lt;code&gt;searchWord&lt;/code&gt;.
Our goal is to suggest three products after typing each character of &lt;code&gt;searchWord&lt;/code&gt;.
This is a tiny autocompletion method!
We could solve this problem with a Trie, like the one we implemented to solve &lt;a href=&#34;http://localhost:1313/posts/leetcode_208.md&#34;&gt;LeetCode problem 208&lt;/a&gt;. Check it out!&lt;/p&gt;
&lt;p&gt;But today, I felt like solving this without writing hyper-optimized or over-engineered code.
Our solution will be simple and straightforward&amp;hellip; but still efficient!
Let&amp;rsquo;s dive in.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Starting out with CUDA C&#43;&#43;</title>
      <link>http://localhost:1313/posts/cuda/cuda_intro/</link>
      <pubDate>Fri, 05 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/cuda/cuda_intro/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been learning about CUDA C++ programming this week, following &lt;a href=&#34;https://developer.nvidia.com/blog/even-easier-introduction-cuda/&#34;&gt;this blog post&lt;/a&gt; by Mark Harris.
What makes CUDA useful is its ability to execute many computations in parallel instead of sequentially.
The linked blog post demonstrates how it can add two very large vectors with a size of 1 million elements each.
I&amp;rsquo;ll present the most interesting code snippets in an approachable way and show how very similar code can perform vector-vector dot products.
You can see the full code in my repository here: &lt;a href=&#34;https://github.com/davidnabergoj/cuda-programming&#34;&gt;https://github.com/davidnabergoj/cuda-programming&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 1143: Longest Common Subsequence</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_1143/</link>
      <pubDate>Thu, 04 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_1143/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll be solving &lt;a href=&#34;https://leetcode.com/problems/longest-common-subsequence&#34;&gt;LeetCode problem 1143&lt;/a&gt;.
We have two strings &lt;code&gt;text1&lt;/code&gt; and &lt;code&gt;text2&lt;/code&gt; with sizes \(n\) and \(m\), respectively.
We want to find the length of their longest common subsequence (LCS).
A subsequence of a string &lt;code&gt;s&lt;/code&gt; is obtained by deleting zero or more characters from &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;strategy&#34;&gt;Strategy&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s assume we have two strings: &lt;code&gt;s1&lt;/code&gt; with size &lt;code&gt;n1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; with size &lt;code&gt;n2&lt;/code&gt;.
Let&amp;rsquo;s also assume we know their LCS length.
What can we say about LCS length when we append a character &lt;code&gt;c1&lt;/code&gt; to &lt;code&gt;s1&lt;/code&gt; and a character &lt;code&gt;c2&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;?&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 2542: Maximum Subsequence Score</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_2542/</link>
      <pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_2542/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll be solving &lt;a href=&#34;https://leetcode.com/problems/maximum-subsequence-score&#34;&gt;LeetCode problem 2542&lt;/a&gt;.
We have two integer arrays &lt;code&gt;nums1&lt;/code&gt; and &lt;code&gt;nums2&lt;/code&gt; with size \(n\), as well as an integer \(k\).
Let&amp;rsquo;s denote &lt;code&gt;nums1&lt;/code&gt; with \(A\) and &lt;code&gt;nums2&lt;/code&gt; with \(B\).
If we pick a set of indices \(S\) with exactly \(k\) elements, we obtain a score as follows:
&lt;/p&gt;
\[
    \min \left\{ B_i | i \in S \right\} \sum_{i \in S} A_i
\]&lt;p&gt;
There are many different sets \(S\) that give different scores.
We want to find the maximum possible score.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 2336: smallest number in infinite set</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_2236/</link>
      <pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_2236/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll be solving &lt;a href=&#34;https://leetcode.com/problems/smallest-number-in-infinite-set&#34;&gt;LeetCode problem 2236&lt;/a&gt;.
We start with an infinite set containing all positive integers.
We may remove and return the smallest integer using &lt;code&gt;int popSmallest()&lt;/code&gt; or add a positive integer back into the set using &lt;code&gt;void addBack(int num)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;strategy&#34;&gt;Strategy&lt;/h2&gt;
&lt;p&gt;If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable &lt;code&gt;n&lt;/code&gt;.
We start with &lt;code&gt;n = 1&lt;/code&gt;.
Each time we pop, we increment &lt;code&gt;n&lt;/code&gt; by one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 208: Trie implementation</title>
      <link>http://localhost:1313/posts/leetcode/leetcode_208/</link>
      <pubDate>Sun, 30 Nov 2025 13:45:28 +0100</pubDate>
      <guid>http://localhost:1313/posts/leetcode/leetcode_208/</guid>
      <description>&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Trie&#34;&gt;trie&lt;/a&gt; is data structure which holds strings.
It allows fast search and insertion of strings, as well as fast search of string prefixes.
This can be especially useful for text autocompletion and spellcheck.&lt;/p&gt;
&lt;p&gt;In this post, we implement a trie in C++ with three basic operations: &lt;code&gt;search&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, and &lt;code&gt;startsWith&lt;/code&gt;.
This is the solution to &lt;a href=&#34;https://leetcode.com/problems/implement-trie-prefix-tree/description/&#34;&gt;LeetCode 208&lt;/a&gt;.
The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
