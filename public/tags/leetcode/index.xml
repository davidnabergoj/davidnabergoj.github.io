<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LeetCode on Sunny Coding</title>
    <link>http://localhost:1313/tags/leetcode/</link>
    <description>Recent content in LeetCode on Sunny Coding</description>
    <generator>Hugo -- 0.152.2</generator>
    <language>en</language>
    <copyright>2025 - David Nabergoj</copyright>
    <lastBuildDate>Thu, 25 Dec 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LeetCode 399: Evaluate Division</title>
      <link>http://localhost:1313/posts/leetcode_399/</link>
      <pubDate>Thu, 25 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_399/</guid>
      <description>&lt;p&gt;Thanks for reading! If you liked this post, you can support me on &lt;a href=&#34;https://ko-fi.com/davidnabergoj&#34;&gt;Ko-fi â˜•&lt;/a&gt;. More LeetCode solutions coming soon :)&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 162: Find Peak Element</title>
      <link>http://localhost:1313/posts/leetcode_162/</link>
      <pubDate>Sun, 14 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_162/</guid>
      <description>&lt;p&gt;Very quick post about finding the peak element in an array.
This is &lt;a href=&#34;https://leetcode.com/problems/find-peak-element&#34;&gt;LeetCode problem 162&lt;/a&gt;.
We have an array &lt;code&gt;nums&lt;/code&gt; with \(n\) integers and want to find the index of one of its peaks in \(O(\log n)\) time.
The important detail is this: no two neighboring elements have the same value.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s dive in!&lt;/p&gt;
&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;
&lt;p&gt;To solve this in logarithmic time, we will use binary search.
We start with a &lt;code&gt;left&lt;/code&gt; index and a &lt;code&gt;right&lt;/code&gt; index.
We then compute a mid point &lt;code&gt;mid = (left + right) / 2&lt;/code&gt;.
Now we investigate what the local behavior around &lt;code&gt;mid&lt;/code&gt; is.
If &lt;code&gt;nums[mid] &amp;gt; nums[mid + 1]&lt;/code&gt;, it means that there&amp;rsquo;s no point searching for the peak at &lt;code&gt;mid + 1&lt;/code&gt; or to its right, so we set &lt;code&gt;right = mid&lt;/code&gt;.
Otherwise, there&amp;rsquo;s no point in searching for the peak at &lt;code&gt;mid&lt;/code&gt; or to its left, so we set &lt;code&gt;left = mid + 1&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 714: Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link>http://localhost:1313/posts/leetcode_714/</link>
      <pubDate>Sun, 14 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_714/</guid>
      <description>&lt;p&gt;Welcome back to another LeetCode walkthrough! Let&amp;rsquo;s look at &lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/&#34;&gt;LeetCode problem 714&lt;/a&gt;.
We&amp;rsquo;re given an array of stock prices. Each day, we can either buy a stock if we have none or sell a stock we own (but not both).
When we sell a stock, we have to pay a transaction fee.
We want to find the maximum profit we can achieve.&lt;/p&gt;
&lt;p&gt;We approach this using dynamic programming.
Let&amp;rsquo;s dive in!&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 1268: Search Suggestions System</title>
      <link>http://localhost:1313/posts/leetcode_1268/</link>
      <pubDate>Sat, 13 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_1268/</guid>
      <description>&lt;p&gt;Welcome back to another LeetCode walkthrough! This time, we&amp;rsquo;ll be tackling &lt;a href=&#34;https://leetcode.com/problems/search-suggestions-system&#34;&gt;LeetCode problem 1268&lt;/a&gt;.
We&amp;rsquo;re given an array of strings called &lt;code&gt;products&lt;/code&gt;, as well as a string &lt;code&gt;searchWord&lt;/code&gt;.
Our goal is to suggest three products after typing each character of &lt;code&gt;searchWord&lt;/code&gt;.
This is a tiny autocompletion method!
We could solve this problem with a Trie, like the one we implemented to solve &lt;a href=&#34;http://localhost:1313/posts/leetcode_208/&#34;&gt;LeetCode problem 208&lt;/a&gt;. Check it out!&lt;/p&gt;
&lt;p&gt;But today, I felt like solving this without writing hyper-optimized or over-engineered code.
Our solution will be simple and straightforward&amp;hellip; but still efficient!
Let&amp;rsquo;s dive in.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 1143: Longest Common Subsequence</title>
      <link>http://localhost:1313/posts/leetcode_1143/</link>
      <pubDate>Thu, 04 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_1143/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll be solving &lt;a href=&#34;https://leetcode.com/problems/longest-common-subsequence&#34;&gt;LeetCode problem 1143&lt;/a&gt;.
We have two strings &lt;code&gt;text1&lt;/code&gt; and &lt;code&gt;text2&lt;/code&gt; with sizes \(n\) and \(m\), respectively.
We want to find the length of their longest common subsequence (LCS).
A subsequence of a string &lt;code&gt;s&lt;/code&gt; is obtained by deleting zero or more characters from &lt;code&gt;s&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;strategy&#34;&gt;Strategy&lt;/h2&gt;
&lt;p&gt;Let&amp;rsquo;s assume we have two strings: &lt;code&gt;s1&lt;/code&gt; with size &lt;code&gt;n1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; with size &lt;code&gt;n2&lt;/code&gt;.
Let&amp;rsquo;s also assume we know their LCS length.
What can we say about LCS length when we append a character &lt;code&gt;c1&lt;/code&gt; to &lt;code&gt;s1&lt;/code&gt; and a character &lt;code&gt;c2&lt;/code&gt; to &lt;code&gt;s2&lt;/code&gt;?&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 2542: Maximum Subsequence Score</title>
      <link>http://localhost:1313/posts/leetcode_2542/</link>
      <pubDate>Wed, 03 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_2542/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll be solving &lt;a href=&#34;https://leetcode.com/problems/maximum-subsequence-score&#34;&gt;LeetCode problem 2542&lt;/a&gt;.
We have two integer arrays &lt;code&gt;nums1&lt;/code&gt; and &lt;code&gt;nums2&lt;/code&gt; with size \(n\), as well as an integer \(k\).
Let&amp;rsquo;s denote &lt;code&gt;nums1&lt;/code&gt; with \(A\) and &lt;code&gt;nums2&lt;/code&gt; with \(B\).
If we pick a set of indices \(S\) with exactly \(k\) elements, we obtain a score as follows:
&lt;/p&gt;
\[
    \min \left\{ B_i | i \in S \right\} \sum_{i \in S} A_i
\]&lt;p&gt;
There are many different sets \(S\) that give different scores.
We want to find the maximum possible score.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 2336: smallest number in infinite set</title>
      <link>http://localhost:1313/posts/leetcode_2236/</link>
      <pubDate>Mon, 01 Dec 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/leetcode_2236/</guid>
      <description>&lt;p&gt;In this post, we&amp;rsquo;ll be solving &lt;a href=&#34;https://leetcode.com/problems/smallest-number-in-infinite-set&#34;&gt;LeetCode problem 2236&lt;/a&gt;.
We start with an infinite set containing all positive integers.
We may remove and return the smallest integer using &lt;code&gt;int popSmallest()&lt;/code&gt; or add a positive integer back into the set using &lt;code&gt;void addBack(int num)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;strategy&#34;&gt;Strategy&lt;/h2&gt;
&lt;p&gt;If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable &lt;code&gt;n&lt;/code&gt;.
We start with &lt;code&gt;n = 1&lt;/code&gt;.
Each time we pop, we increment &lt;code&gt;n&lt;/code&gt; by one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>LeetCode 208: Trie implementation</title>
      <link>http://localhost:1313/posts/leetcode_208/</link>
      <pubDate>Sun, 30 Nov 2025 13:45:28 +0100</pubDate>
      <guid>http://localhost:1313/posts/leetcode_208/</guid>
      <description>&lt;p&gt;A &lt;a href=&#34;https://en.wikipedia.org/wiki/Trie&#34;&gt;trie&lt;/a&gt; is data structure which holds strings.
It allows fast search and insertion of strings, as well as fast search of string prefixes.
This can be especially useful for text autocompletion and spellcheck.&lt;/p&gt;
&lt;p&gt;In this post, we implement a trie in C++ with three basic operations: &lt;code&gt;search&lt;/code&gt;, &lt;code&gt;insert&lt;/code&gt;, and &lt;code&gt;startsWith&lt;/code&gt;.
This is the solution to &lt;a href=&#34;https://leetcode.com/problems/implement-trie-prefix-tree/description/&#34;&gt;LeetCode 208&lt;/a&gt;.
The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
