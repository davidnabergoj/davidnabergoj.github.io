[{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices $S$ with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\{ \\texttt{nums2[i]} \\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices $S$ with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\{ \\texttt{nums2[i]} \\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\{ \\texttt{nums2[i]} \\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\{ \\texttt{nums2[i]} \\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy Full solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy Full solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy We\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy We can sort nums2 in non-increasing order.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy We can sort nums2 in non-increasing order. Each value will be less than the previous one.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy We can sort nums2 in non-increasing order. Each value will be less or equal to the previous one.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy Instead of picking indices, we\nWe can sort nums2 in non-increasing order. Each value will be less or equal to the previous one.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy Instead of picking indices, we\nWe can sort nums2 in non-increasing order. Each value will be less or equal to the previous one.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(n! / (k! (n-k)!)\\) We want an more effective way of picking the indices.\nWe can sort nums2 in non-increasing order. Each value will be less or equal to the previous one.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\) We want an more effective way of picking the indices.\nWe can sort nums2 in non-increasing order. Each value will be less or equal to the previous one.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices.\nWe can sort nums2 in non-increasing order. Each value will be less or equal to the previous one.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nWe can sort nums2 in non-increasing order. Each value will be less or equal to the previous one.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Each value will be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value will be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. If we scan the arrays from left to right and look at a sliding window for\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. If we scan the arrays from left to right and look at a sliding window for\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. If we scan the arrays from left to right and look at a sliding window for\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch!\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index could still be in the solution set \\(S\\)\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] for i \u0026gt; j.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, noting that i is always included.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full solution! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full cde! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer k. If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \u003ccode\u003ek\u003c/code\u003e.\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(K\\). If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(K\\).\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(k\\). If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(k\\).\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\texttt{score} = \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min_{i \\in S} \\left\\{ \\texttt{nums2[i]} \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\min_{i \\in S} \\left\\{ a_i \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min_{i \\in S} \\left\\{ a_i \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\min \\left\\{ a_i | i \\in S \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ a_i | i \\in S \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} \\texttt{nums1[i]}\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly k elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size k sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe k elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous k values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size k sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size k. The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \u003ccode\u003ek\u003c/code\u003e elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2, as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size \\(k\\) sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k\\) values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e, as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of size \\(k\\) sets for arrays of size n is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k\\) values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(\\texttt{n}! / (\\texttt{k}! (\\texttt{n}-\\texttt{k})!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k\\) values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting nums2 in non-increasing order. Because the two arrays are connected, we sort nums2 using the same order. Each value of nums2 will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k\\) values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(b\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k\\) values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k\\) values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score. We will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score. We will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score. We will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score. We will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); // reverse-sort ascending \u0026lt;=\u0026gt; forward-sort descending If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score. We will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score. We will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over nums1 to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of nums1 that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of nums1 up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of \\(a\\) that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between 0 and i, with i always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of \\(a\\) that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of \\(a\\) that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, nums2[i] is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of \\(a\\) that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as nums2[j] cannot be less than nums2[i] (the current element) for i \u0026gt; j.\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of \\(a\\) that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than nums2[i] (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of \\(a\\) that greatly contributes to the score, but is not within the window. The corresponding index j could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! It\u0026rsquo;s possible that there\u0026rsquo;s an element of \\(a\\) that greatly contributes to the score, but is not within the window. The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element of \\(a\\) that greatly contributes to the score, but is not within the window. The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) that greatly contributes to the score, but is not within the window. The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) that greatly contributes to the score, but is not within the window \\((j \u003c i - k\u003e)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) that greatly contributes to the score, but is not within the window \\((j \u003c i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \u003c i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \u003c= i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) (the current element) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\) for \\(i \u003e j\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); If we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\nFull solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } if (pq.size() == k) { bestScore = max(bestScore, currentSum * pairs[i].first); } } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } if (pq.size() == k) { bestScore = max(bestScore, currentSum * pairs[i].first); } } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } // Update the best score after the priority queue has enough elements if (pq.size() == k) { bestScore = max(bestScore, currentSum * pairs[i].first); } } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // fix the sum pq.pop(); } // Update the best score after the priority queue has enough elements if (pq.size() == k) { bestScore = max(bestScore, currentSum * pairs[i].first); } } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // update the sum // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // fix the sum pq.pop(); } // Update the best score after the priority queue has enough elements if (pq.size() == k) { bestScore = max(bestScore, currentSum * pairs[i].first); } } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1 long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // update the sum // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // fix the sum pq.pop(); } // Update the best score after the priority queue has enough elements if (pq.size() == k) { bestScore = max(bestScore, currentSum * pairs[i].first); } } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // update the sum // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // fix the sum pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Fix the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nThanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); // reverse-sort ascending \u0026lt;=\u0026gt; forward-sort descending priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); // sort descending priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); // sort descending priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(a\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(a\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(a\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(a\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(a\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(a\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(a\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(b\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(b\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(b\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(b\\) together according to values of \\(b\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(b\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(b\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(a_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(b_j\\) cannot be less than \\(b_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(b_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ b_i | i \\in S \\right\\} \\sum_{i \\in S} a_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k \\) time for insertions. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - k\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - k\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - k\\) priority queue deletions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - k\\) priority queue pops, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - k\\) priority queue pops, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for popping. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - (k - 1)\\) priority queue pops, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for popping. #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - (k - 1)\\) priority queue pops, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for popping since \\(n \\geq k\\). #include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - (k - 1)\\) priority queue pops, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for popping since \\(n \\geq k\\). The total runtime is dominated by the initial sorting process and the overall complexity is thus \\(O(n \\log n)\\).\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - (k - 1)\\) priority queue pops, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for popping since \\(n \\geq k\\). The total runtime is dominated by the initial sorting process. If \\(k\\) is much less than \\(n\\), then overall complexity is \\(O(n \\log n)\\). Otherwise, we can more precisely say the time complexity is \\(O(n\\log n + n\\log k)\\)\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2542. We have two integer arrays nums1 and nums2 with size \\(n\\), as well as an integer \\(k\\). Let\u0026rsquo;s denote nums1 with \\(A\\) and nums2 with \\(B\\). If we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows: \\[\r\\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\\] There are many different sets \\(S\\) that give different scores. We want to find the maximum possible score.\nStrategy The total number of possible sets is \\(n! / (k! (n-k)!)\\), which is too big to make a brute-force solution feasible. We want an more effective way of picking the indices. If we can somehow sort the two arrays, then we may be able to observe \\(k\\) elements from left to right in a sliding window manner.\nLet\u0026rsquo;s try sorting \\(B\\) in non-increasing order. Because the two arrays are connected, we sort \\(A\\) using the same order. Each value of \\(B\\) will now be less or equal to the previous one. What\u0026rsquo;s more, it will be less than the previous \\(k - 1\\) values. This will be our minimum term for the score.\nWe will work with a vector of pairs to make sorting easy. This requires an extra \\(O(n)\\) space, but the overall space complexity is \\(O(n)\\) anyway for the input arrays. The sort function will sort \\(A\\) and \\(B\\) together according to values of \\(B\\) first. This is because they are the first in each pair. We use rbegin and rend to get a reversed ascending-order output, which is equivalent to a standard descending-order output.\nvector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); From this point, we treat \\(A\\) and \\(B\\) to be sorted as discussed above.\nIf we scan the arrays from left to right, we could impose a size \\(k\\) sliding window over \\(A\\) to keep track of the sum term. But there\u0026rsquo;s a catch! Say we\u0026rsquo;re at index \\(i\\). It\u0026rsquo;s possible that there\u0026rsquo;s an element \\(A_j\\) at index \\(j \u003c i\\) that greatly contributes to the score, but is not within the window \\((j \\leq i - k)\\). The corresponding index \\(j\\) could still be in the solution set \\(S\\) and the minimum term would not change, as \\(B_j\\) cannot be less than \\(B_i\\).\nInstead of a sliding window, we can keep a priority queue of size \\(k\\). The first element is the smallest element of \\(A\\) up to \\(i\\) \u0026ndash; the current index. As we loop through the sorted array, we fill the priority queue until it\u0026rsquo;s too large, at which point we pop the smallest element. This effectively defines \\(S\\) as indices between \\(0\\) and \\(i\\), with \\(i\\) always being included. At the same time, \\(B_i\\) is always the minimum term for the score computation. We keep track of the current sum term value, making sure to subtract values that we pop from the priority queue.\npriority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; // min-heap (smallest element on top) long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } // Start the second loop at k - 1, after the priority queue long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; // Update the sum term // Ensure we are always observing at most k elements if (pq.size() \u0026gt; k) { currentSum -= pq.top(); // Correct the sum term pq.pop(); } // Update the best score after the priority queue has exactly k elements bestScore = max(bestScore, currentSum * pairs[i].first); } Full solution and time complexity analysis Below is the full code! It passes all tests with a runtime of 71ms and 94.8 MB memory usage.\nWe break down the time complexity as follows:\nwe need \\(O(n \\log n)\\) time for sorting. we perform \\(n\\) priority queue insertions, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for insertions. we perform \\(n - (k - 1)\\) priority queue pops, each with complexity \\(O(\\log k)\\), leading to \\(O (n \\log k) \\) time for popping since \\(n \\geq k\\). The total runtime is dominated by the initial sorting process. If \\(k\\) is much less than \\(n\\), then overall complexity is \\(O(n \\log n)\\). Otherwise, we can more precisely say the time complexity is \\(O(n\\log n + n\\log k)\\).\n#include \u0026lt;algorithm\u0026gt; #include \u0026lt;queue\u0026gt; class Solution { public: long long maxScore(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int k) { vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; pairs(nums1.size()); for (size_t i = 0; i \u0026lt; pairs.size(); i++) { pairs[i] = {nums2[i], nums1[i]}; } std::sort(rbegin(pairs), rend(pairs)); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; pq; long long currentSum = 0; for (size_t i = 0; i \u0026lt; k - 1; i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; } long long bestScore = 0; for (size_t i = k - 1; i \u0026lt; pairs.size(); i++) { pq.push(pairs[i].second); currentSum += pairs[i].second; if (pq.size() \u0026gt; k) { currentSum -= pq.top(); pq.pop(); } bestScore = max(bestScore, currentSum * pairs[i].first); } return bestScore; } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2542/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/maximum-subsequence-score\"\u003eLeetCode problem 2542\u003c/a\u003e.\nWe have two integer arrays \u003ccode\u003enums1\u003c/code\u003e and \u003ccode\u003enums2\u003c/code\u003e with size \\(n\\), as well as an integer \\(k\\).\nLet\u0026rsquo;s denote \u003ccode\u003enums1\u003c/code\u003e with \\(A\\) and \u003ccode\u003enums2\u003c/code\u003e with \\(B\\).\nIf we pick a set of indices \\(S\\) with exactly \\(k\\) elements, we obtain a score as follows:\n\u003c/p\u003e\n\\[\r\n    \\min \\left\\{ B_i | i \\in S \\right\\} \\sum_{i \\in S} A_i\r\n\\]\u003cp\u003e\nThere are many different sets \\(S\\) that give different scores.\nWe want to find the maximum possible score.\u003c/p\u003e","title":"Leetcode 2542: Maximum Subsequence Score"},{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/leetcode_2236/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/leetcode_208/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"}]