[{"content":"In this post, we\u0026rsquo;ll be solving LeetCode problem 2236. We start with an infinite set containing all positive integers. We may remove and return the smallest integer using int popSmallest() or add a positive integer back into the set using void addBack(int num).\nStrategy If we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable n. We start with n = 1. Each time we pop, we increment n by one.\nWe only add num back into the set if num \u0026lt; n, as it is otherwise already in the set. If we successfully add num back, it will surely be smaller than n, so any further popSmallest calls should get rid of such numbers first. What\u0026rsquo;s more, we want to pop the smallest of the added num values first.\nWe implement this with a priority queue, which allows us to retrieve the smallest (alternatively, the largest) number inside it in \\(O(1)\\) time, pop it in \\(O(\\log m)\\) time, and insert a new value in \\(O(\\log m)\\) time. Here, \\(m\\) is the number of elements in the priority queue.\nAll numbers placed into the set via addBack are thus put into the priority queue. Whenever we call popSmallest, we first attempt to return the smallest value in the priority queue. If the queue is empty, we instead increment n.\nThere is a small catch: we may add the same num back several times. The priority queue will contain multiple copies. Such duplicates cannot appear in the infinite set. We handle this in popSmallest by observing the smallest element in the queue and store it into a variable output. We then pop from the queue until the smallest element changes. We finally return output.\nFull solution Below is the full solution for the LeetCode problem. Some notes:\nTo create the minPriorityQueue object in C++, we need specify the data type (int), the base data container (vector\u0026lt;int\u0026gt;), and the comparator which will ensure that the top element of the queue is always the smallest one inside it. In popSmallest, we write return n++;, which first returns n to a caller function, then increments its value inside the SmallestInfiniteSet instance. We could equivalently write n++; return n - 1; During my submission, the code needed 10ms of runtime and 43.1 MB of memory.\n#include \u0026lt;queue\u0026gt; class SmallestInfiniteSet { public: int n = 1; priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minPriorityQueue; SmallestInfiniteSet() { } int popSmallest() { int output; if (!minPriorityQueue.empty()) { output = minPriorityQueue.top(); while (!minPriorityQueue.empty() \u0026amp;\u0026amp; output == minPriorityQueue.top()) { minPriorityQueue.pop(); } return output; } else { return n++; } } void addBack(int num) { if (num \u0026lt; n) { minPriorityQueue.push(num); } } }; Thanks for reading! More LeetCode solutions coming soon :)\n","permalink":"http://localhost:1313/posts/infinite_set/","summary":"\u003cp\u003eIn this post, we\u0026rsquo;ll be solving \u003ca href=\"https://leetcode.com/problems/smallest-number-in-infinite-set\"\u003eLeetCode problem 2236\u003c/a\u003e.\nWe start with an infinite set containing all positive integers.\nWe may remove and return the smallest integer using \u003ccode\u003eint popSmallest()\u003c/code\u003e or add a positive integer back into the set using \u003ccode\u003evoid addBack(int num)\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"strategy\"\u003eStrategy\u003c/h2\u003e\n\u003cp\u003eIf we only focus on popping smallest integers, then we only need to keep track of the smallest number in the set with a variable \u003ccode\u003en\u003c/code\u003e.\nWe start with \u003ccode\u003en = 1\u003c/code\u003e.\nEach time we pop, we increment \u003ccode\u003en\u003c/code\u003e by one.\u003c/p\u003e","title":"Leetcode 2336: smallest number in infinite set"},{"content":"A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nTrie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word \u0026ldquo;apple\u0026rdquo;, but not \u0026ldquo;app\u0026rdquo;. Searching for \u0026ldquo;app\u0026rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word \u0026ldquo;app\u0026rdquo;. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor } Recursive solution search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn\u0026rsquo;t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } It\u0026rsquo;s important to note that word.substr(1) creates another string object with just one element less than the original word. If \\(m\\) is the length of the word, this makes the recursion\u0026rsquo;s time complexity to \\(O(m^2)\\) and results in \\(O(m^2)\\) total allocated space. We could avoid allocating new memory by either:\ntreating word as a character array and incrementing the pointer to its beginning, passing in the index of the current word character, or using std::string_view from C++17 and greater. This would reduce the time complexity to the much more preferable \\(O(m)\\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode\u0026rsquo;s framework. We\u0026rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.\ninsert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u0026gt;insert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;search(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u0026gt;startsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u0026lt;Trie*\u0026gt; next = vector\u0026lt;Trie*\u0026gt;(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - \u0026#39;a\u0026#39;; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { t-\u0026gt;next[idx] = new Trie(); } t = t-\u0026gt;next[idx]; } t-\u0026gt;wordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u0026lt; word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return t-\u0026gt;wordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u0026lt; prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u0026gt;next[idx]) { return false; } t = t-\u0026gt;next[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n","permalink":"http://localhost:1313/posts/simple_trie/","summary":"\u003cp\u003eA \u003ca href=\"https://en.wikipedia.org/wiki/Trie\"\u003etrie\u003c/a\u003e is data structure which holds strings.\nIt allows fast search and insertion of strings, as well as fast search of string prefixes.\nThis can be especially useful for text autocompletion and spellcheck.\u003c/p\u003e\n\u003cp\u003eIn this post, we implement a trie in C++ with three basic operations: \u003ccode\u003esearch\u003c/code\u003e, \u003ccode\u003einsert\u003c/code\u003e, and \u003ccode\u003estartsWith\u003c/code\u003e.\nThis is the solution to \u003ca href=\"https://leetcode.com/problems/implement-trie-prefix-tree/description/\"\u003eLeetCode 208\u003c/a\u003e.\nThe problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\u003c/p\u003e","title":"Trie implementation"},{"content":"\nHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics. I use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\nI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana. For the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses. I do a lot of research on normalizing flows, a special family of generative models. I use flows to speed up MCMC by transforming difficult data spaces into simple ones. I\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley. I\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation. I\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\nFeel free to check out some of my recent papers:\nEmpirical evaluation of normalizing flows in Markov chain Monte Carlo (2025) Reducing normalizing flow complexity for MCMC preconditioning (2025) Control, Transport and Sampling: Towards Better Loss Design (2024) Accelerating astronomical and cosmological inference with preconditioned Monte Carlo (2022) I have a Github page that you\u0026rsquo;re welcome to follow and a LinkedIn profile for business. You can also send me an email: david at nabergoj dot org.\n","permalink":"http://localhost:1313/about/","summary":"\u003cp\u003e\u003cimg alt=\"David\" loading=\"lazy\" src=\"/david.jpg#avatar\"\u003e\u003c/p\u003e\n\u003cp\u003eHi! I\u0026rsquo;m David Nabergoj, a computer science researcher with a passion for machine learning, programming, and mathematics.\nI use this blog to share my learning journey, implement ML projects, and post solutions to interesting algorithm challenges.\u003c/p\u003e\n\u003cp\u003eI\u0026rsquo;m currently pursuing my PhD in computer science at the University of Ljubljana.\nFor the last four years, I\u0026rsquo;ve also been a TA for postgraduate probability and statistics courses.\nI do a lot of research on normalizing flows, a special family of generative models.\nI use flows to speed up MCMC by transforming difficult data spaces into simple ones.\nI\u0026rsquo;ve worked with fantastic people at the University of Ljubljana and UC Berkeley.\nI\u0026rsquo;ve delivered talks for the Flatiron institute and the American Slovenian Education Foundation.\nI\u0026rsquo;m also very proud and privileged to have won an award at the 2021 NASA/ESA/JAXA Earth Observation Dashboard competition with five amazing teammates.\u003c/p\u003e","title":"About Me"}]