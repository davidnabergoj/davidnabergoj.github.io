<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Trie implementation | Sunny Coding</title>
<meta name="keywords" content="Data structures, Leetcode, C&#43;&#43;, Recursion">
<meta name="description" content="A trie is data structure which holds strings.
It allows fast search and insertion of strings, as well as fast search of string prefixes.
This can be especially useful for text autocompletion and spellcheck.
In this post, we implement a trie in C&#43;&#43; with three basic operations: search, insert, and startsWith.
This is the solution to LeetCode 208.
The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.">
<meta name="author" content="David Nabergoj">
<link rel="canonical" href="http://localhost:1313/posts/simple_trie/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/posts/simple_trie/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>

</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Sunny Coding (Alt + H)">Sunny Coding</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Trie implementation
    </h1>
    <div class="post-meta"><span title='2025-11-30 13:45:28 +0100 S'>November 30, 2025</span>&nbsp;·&nbsp;<span>David Nabergoj</span>

</div>
  </header> 
  <div class="post-content"><p>A <a href="https://en.wikipedia.org/wiki/Trie">trie</a> is data structure which holds strings.
It allows fast search and insertion of strings, as well as fast search of string prefixes.
This can be especially useful for text autocompletion and spellcheck.</p>
<p>In this post, we implement a trie in C++ with three basic operations: <code>search</code>, <code>insert</code>, and <code>startsWith</code>.
This is the solution to <a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">LeetCode 208</a>.
The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.</p>
<h1 id="trie-class"><code>Trie</code> class<a hidden class="anchor" aria-hidden="true" href="#trie-class">#</a></h1>
<p>We implement the trie as a a tree.
Each node contains a fixed vector of pointers (called <code>next</code>) to tries below it.
Each pointer corresponds to a different character.
For example, <code>next['f']</code> corresponds to words with the substring.</p>
<p>We use a boolean <code>wordEnd</code> indicating that there exists a word that ends in the current trie root.
An example where this is useful: the trie contains the word &ldquo;apple&rdquo;, but not &ldquo;app&rdquo;. Searching for &ldquo;app&rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word &ldquo;app&rdquo;.
This boolean lets us avoid the ambiguity.</p>
<p>We create a helper method <code>getIndex</code> that takes a character of</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span> next <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">26</span>, <span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> wordEnd <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getIndex</span>(<span style="color:#66d9ef">char</span> query) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> query <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Trie() {}  <span style="color:#75715e">// Class constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h1 id="recursive-solution">Recursive solution<a hidden class="anchor" aria-hidden="true" href="#recursive-solution">#</a></h1>
<h2 id="search"><code>search</code><a hidden class="anchor" aria-hidden="true" href="#search">#</a></h2>
<p>To search for a word in the trie, we start at the root and check if the pointer <code>next[c]</code>, corresponding to the first character <code>c</code>, is not null.
If it is null, the word is not present and we return <code>false</code>.
If it isn&rsquo;t, we recursively search if the remainder of the word is found in <code>next[c]</code>.
If the word has no characters, we return <code>true</code>. This is the base case for recursion.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">search</span>(string word) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (word.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> wordEnd;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> getIndex(word[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next[index]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> next[index]<span style="color:#f92672">-&gt;</span>search(word.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s important to note that <code>word.substr(1)</code> creates another string object with just one element less than the original <code>word</code>. If \(m\) is the length of the <code>word</code>, this makes the recursion&rsquo;s time complexity to \(O(m^2)\) and results in \(O(m^2)\) total allocated space. We could avoid allocating new memory by either:</p>
<ul>
<li>treating word as a character array and incrementing the pointer to its beginning,</li>
<li>passing in the index of the current word character, or</li>
<li>using <code>std::string_view</code> from C++17 and greater.</li>
</ul>
<p>This would reduce the time complexity to the much more preferable \(O(m)\) and requires no additional allocated space. However, we keep this recursive implementation as it does not modify LeetCode&rsquo;s framework. We&rsquo;ll see later that an iterative solution makes this easy and avoids pointer manipulation.</p>
<h2 id="insert"><code>insert</code><a hidden class="anchor" aria-hidden="true" href="#insert">#</a></h2>
<p>Inserting a word into the trie is conceptualy similar to searching for it.
We check if there is a trie, corresponding to the first character of <code>word</code>.
If not, we create a trie for that character.
Now that the trie surely exists, we insert the remainder of <code>word</code> into it.
If the word has no characters, it has been fully inserted into the trie.
At that point, we set <code>wordEnd = true</code> to indicate that the word belongs to the trie (separating it from its substrings).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(string word) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (word.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        wordEnd <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(word[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(next[idx])) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If the Trie does not exist yet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        next[idx] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Trie();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    next[idx]<span style="color:#f92672">-&gt;</span>insert(word.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="startswith"><code>startsWith</code><a hidden class="anchor" aria-hidden="true" href="#startswith">#</a></h2>
<p>The <code>startsWith</code> function is very similar to the <code>search</code> function.
The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists.
The only difference between <code>search</code> and <code>startsWith</code> is thus not checking if the word is contained in the trie during the recursive base case.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">startsWith</span>(string prefix) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Returns `true` if there is a previously inserted word
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       that starts with `prefix`, and `false` otherwise. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (prefix.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> getIndex(prefix[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next[index]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> next[index]<span style="color:#f92672">-&gt;</span>startsWith(prefix.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="full-recursive-solution">Full recursive solution<a hidden class="anchor" aria-hidden="true" href="#full-recursive-solution">#</a></h2>
<p>We provide the full recursive solution below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span> {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span> next <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">26</span>, <span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> wordEnd <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getIndex</span>(<span style="color:#66d9ef">char</span> query) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> query <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Trie() {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(string word) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (word.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            wordEnd <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(word[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(next[idx])) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// If the Trie does not exist yet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            next[idx] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Trie();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        next[idx]<span style="color:#f92672">-&gt;</span>insert(word.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">search</span>(string word) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (word.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> wordEnd;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> getIndex(word[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next[index]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> next[index]<span style="color:#f92672">-&gt;</span>search(word.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">startsWith</span>(string prefix) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (prefix.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> getIndex(prefix[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next[index]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> next[index]<span style="color:#f92672">-&gt;</span>startsWith(prefix.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="iterative-solution">Iterative solution<a hidden class="anchor" aria-hidden="true" href="#iterative-solution">#</a></h1>
<p>The recursive solution is valid, but contains two sources of avoidable overhead:</p>
<ul>
<li>For even moderately long words, we risk stack overflow and add considerable CPU overhead.</li>
<li>Recursive calls use stack memory proportional to recursion depth (word length).</li>
</ul>
<p>We can avoid recursively entering a new stack frame when inserting a new word.
Instead, we start with the root trie pointer and iteratively change it within a loop over word characters.
Staying in a single frame like this is faster and uses less space.
We modify the <code>search</code> and <code>startsWith</code> functions in a similar manner.</p>
<p>Below is the fully modified iterative solution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span> {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span> next <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">26</span>, <span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> wordEnd <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getIndex</span>(<span style="color:#66d9ef">char</span> query) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> query <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Trie() {}  <span style="color:#75715e">// Class constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(string word) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Insert `word` into the trie
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Trie<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> word.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(word[i]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>next[idx]) {
</span></span><span style="display:flex;"><span>                t<span style="color:#f92672">-&gt;</span>next[idx] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Trie();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next[idx];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        t<span style="color:#f92672">-&gt;</span>wordEnd <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">search</span>(string word) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Return true if the trie contains `word` and false otherwise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Trie<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> word.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(word[i]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>next[idx]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next[idx];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> t<span style="color:#f92672">-&gt;</span>wordEnd;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">startsWith</span>(string prefix) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Return true if the trie contains a word that starts with `prefix`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Trie<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> prefix.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(prefix[i]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>next[idx]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next[idx];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="comparison-between-recursive-and-iterative-solutions">Comparison between recursive and iterative solutions<a hidden class="anchor" aria-hidden="true" href="#comparison-between-recursive-and-iterative-solutions">#</a></h1>
<p>The actual runtime and memory consumption are indeed smaller for the iterative solution.
Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/data-structures/">Data Structures</a></li>
      <li><a href="http://localhost:1313/tags/leetcode/">Leetcode</a></li>
      <li><a href="http://localhost:1313/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      <li><a href="http://localhost:1313/tags/recursion/">Recursion</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Sunny Coding</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
