<!DOCTYPE html>
<html lang="en" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Trie implementation | Sunny Coding</title>
<meta name="keywords" content="Data structures, Leetcode, C&#43;&#43;, Recursion">
<meta name="description" content="A trie is data structure which holds strings.
It allows fast search and insertion of strings, as well as fast search of string prefixes.
This can be especially useful for text autocompletion and spellcheck.
In this post, we implement a trie in C&#43;&#43; with three basic operations: search, insert, and startsWith.
This is the solution to LeetCode 208.
The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.">
<meta name="author" content="David Nabergoj">
<link rel="canonical" href="https://nabergoj.org/posts/simple_trie/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.fd5566c526ae48aadabd950798a2dc3568536401560eae5caac3765a42a9e7b5.css" integrity="sha256-/VVmxSauSKravZUHmKLcNWhTZAFWDq5cqsN2WkKp57U=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://nabergoj.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nabergoj.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nabergoj.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://nabergoj.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://nabergoj.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://nabergoj.org/posts/simple_trie/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://nabergoj.org/posts/simple_trie/">
  <meta property="og:site_name" content="Sunny Coding">
  <meta property="og:title" content="Trie implementation">
  <meta property="og:description" content="A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.
In this post, we implement a trie in C&#43;&#43; with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-11-30T13:45:28+01:00">
    <meta property="article:modified_time" content="2025-11-30T13:45:28+01:00">
    <meta property="article:tag" content="Data Structures">
    <meta property="article:tag" content="Leetcode">
    <meta property="article:tag" content="C&#43;&#43;">
    <meta property="article:tag" content="Recursion">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Trie implementation">
<meta name="twitter:description" content="A trie is data structure which holds strings.
It allows fast search and insertion of strings, as well as fast search of string prefixes.
This can be especially useful for text autocompletion and spellcheck.
In this post, we implement a trie in C&#43;&#43; with three basic operations: search, insert, and startsWith.
This is the solution to LeetCode 208.
The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://nabergoj.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Trie implementation",
      "item": "https://nabergoj.org/posts/simple_trie/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Trie implementation",
  "name": "Trie implementation",
  "description": "A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\n",
  "keywords": [
    "Data structures", "Leetcode", "C++", "Recursion"
  ],
  "articleBody": "A trie is data structure which holds strings. It allows fast search and insertion of strings, as well as fast search of string prefixes. This can be especially useful for text autocompletion and spellcheck.\nIn this post, we implement a trie in C++ with three basic operations: search, insert, and startsWith. This is the solution to LeetCode 208. The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.\nRecursive solution Trie class We implement the trie as a a tree. Each node contains a fixed vector of pointers (called next) to tries below it. Each pointer corresponds to a different character. For example, next['f'] corresponds to words with the substring.\nWe use a boolean wordEnd indicating that there exists a word that ends in the current trie root. An example where this is useful: the trie contains the word “apple”, but not “app”. Searching for “app” would otherwise be possible, as there exists a path from the root that contains all characters of the word “app”. This boolean lets us avoid the ambiguity.\nWe create a helper method getIndex that takes a character of\nclass Trie { private: vector\u003cTrie*\u003e next = vector\u003cTrie*\u003e(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - 'a'; } public: Trie() {} // Class constructor } search To search for a word in the trie, we start at the root and check if the pointer next[c], corresponding to the first character c, is not null. If it is null, the word is not present and we return false. If it isn’t, we recursively search if the remainder of the word is found in next[c]. If the word has no characters, we return true. This is the base case for recursion.\nbool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u003esearch(word.substr(1)); } insert Inserting a word into the trie is conceptualy similar to searching for it. We check if there is a trie, corresponding to the first character of word. If not, we create a trie for that character. Now that the trie surely exists, we insert the remainder of word into it. If the word has no characters, it has been fully inserted into the trie. At that point, we set wordEnd = true to indicate that the word belongs to the trie (separating it from its substrings).\nvoid insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u003einsert(word.substr(1)); } startsWith The startsWith function is very similar to the search function. The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists. The only difference between search and startsWith is thus not checking if the word is contained in the trie during the recursive base case.\nbool startsWith(string prefix) { /* Returns `true` if there is a previously inserted word that starts with `prefix`, and `false` otherwise. */ if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u003estartsWith(prefix.substr(1)); } Full recursive solution We provide the full recursive solution below.\nclass Trie { vector\u003cTrie*\u003e next = vector\u003cTrie*\u003e(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - 'a'; } public: Trie() { } void insert(string word) { if (word.size() == 0) { wordEnd = true; return; } int idx = getIndex(word[0]); if (!(next[idx])) { // If the Trie does not exist yet next[idx] = new Trie(); } next[idx]-\u003einsert(word.substr(1)); } bool search(string word) { if (word.size() == 0) { return wordEnd; } int index = getIndex(word[0]); if (!next[index]) { return false; } return next[index]-\u003esearch(word.substr(1)); } bool startsWith(string prefix) { if (prefix.size() == 0) { return true; } int index = getIndex(prefix[0]); if (!next[index]) { return false; } return next[index]-\u003estartsWith(prefix.substr(1)); } }; Iterative solution The recursive solution is valid, but contains two sources of avoidable overhead:\nFor even moderately long words, we risk stack overflow and add considerable CPU overhead. Recursive calls use stack memory proportional to recursion depth (word length). We can avoid recursively entering a new stack frame when inserting a new word. Instead, we start with the root trie pointer and iteratively change it within a loop over word characters. Staying in a single frame like this is faster and uses less space. We modify the search and startsWith functions in a similar manner.\nBelow is the fully modified iterative solution.\nclass Trie { vector\u003cTrie*\u003e next = vector\u003cTrie*\u003e(26, nullptr); bool wordEnd = false; int getIndex(char query) { return query - 'a'; } public: Trie() {} // Class constructor void insert(string word) { // Insert `word` into the trie Trie* t = this; for (int i = 0; i \u003c word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u003enext[idx]) { t-\u003enext[idx] = new Trie(); } t = t-\u003enext[idx]; } t-\u003ewordEnd = true; } bool search(string word) { // Return true if the trie contains `word` and false otherwise Trie* t = this; for (int i = 0; i \u003c word.size(); i++) { int idx = getIndex(word[i]); if (!t-\u003enext[idx]) { return false; } t = t-\u003enext[idx]; } return t-\u003ewordEnd; } bool startsWith(string prefix) { // Return true if the trie contains a word that starts with `prefix` Trie* t = this; for (int i = 0; i \u003c prefix.size(); i++) { int idx = getIndex(prefix[i]); if (!t-\u003enext[idx]) { return false; } t = t-\u003enext[idx]; } return true; } }; Comparison between recursive and iterative solutions The actual runtime and memory consumption are indeed smaller for the iterative solution. Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.\n",
  "wordCount" : "981",
  "inLanguage": "en",
  "datePublished": "2025-11-30T13:45:28+01:00",
  "dateModified": "2025-11-30T13:45:28+01:00",
  "author":{
    "@type": "Person",
    "name": "David Nabergoj"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://nabergoj.org/posts/simple_trie/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Sunny Coding",
    "logo": {
      "@type": "ImageObject",
      "url": "https://nabergoj.org/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://nabergoj.org/" accesskey="h" title="Sunny Coding (Alt + H)">Sunny Coding</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Trie implementation
    </h1>
    <div class="post-meta"><span title='2025-11-30 13:45:28 +0100 S'>November 30, 2025</span>&nbsp;·&nbsp;<span>David Nabergoj</span>

</div>
  </header> 
  <div class="post-content"><p>A <a href="https://en.wikipedia.org/wiki/Trie">trie</a> is data structure which holds strings.
It allows fast search and insertion of strings, as well as fast search of string prefixes.
This can be especially useful for text autocompletion and spellcheck.</p>
<p>In this post, we implement a trie in C++ with three basic operations: <code>search</code>, <code>insert</code>, and <code>startsWith</code>.
This is the solution to <a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/">LeetCode 208</a>.
The problem assumes that all words use characters a-z in the English alphabet, but our solution can be extended to include more characters.</p>
<h1 id="recursive-solution">Recursive solution<a hidden class="anchor" aria-hidden="true" href="#recursive-solution">#</a></h1>
<h2 id="trie-class"><code>Trie</code> class<a hidden class="anchor" aria-hidden="true" href="#trie-class">#</a></h2>
<p>We implement the trie as a a tree.
Each node contains a fixed vector of pointers (called <code>next</code>) to tries below it.
Each pointer corresponds to a different character.
For example, <code>next['f']</code> corresponds to words with the substring.</p>
<p>We use a boolean <code>wordEnd</code> indicating that there exists a word that ends in the current trie root.
An example where this is useful: the trie contains the word &ldquo;apple&rdquo;, but not &ldquo;app&rdquo;. Searching for &ldquo;app&rdquo; would otherwise be possible, as there exists a path from the root that contains all characters of the word &ldquo;app&rdquo;.
This boolean lets us avoid the ambiguity.</p>
<p>We create a helper method <code>getIndex</code> that takes a character of</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span> next <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">26</span>, <span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> wordEnd <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getIndex</span>(<span style="color:#66d9ef">char</span> query) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> query <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Trie() {}  <span style="color:#75715e">// Class constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="search"><code>search</code><a hidden class="anchor" aria-hidden="true" href="#search">#</a></h2>
<p>To search for a word in the trie, we start at the root and check if the pointer <code>next[c]</code>, corresponding to the first character <code>c</code>, is not null.
If it is null, the word is not present and we return <code>false</code>.
If it isn&rsquo;t, we recursively search if the remainder of the word is found in <code>next[c]</code>.
If the word has no characters, we return <code>true</code>. This is the base case for recursion.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">search</span>(string word) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (word.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> wordEnd;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> getIndex(word[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next[index]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> next[index]<span style="color:#f92672">-&gt;</span>search(word.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="insert"><code>insert</code><a hidden class="anchor" aria-hidden="true" href="#insert">#</a></h2>
<p>Inserting a word into the trie is conceptualy similar to searching for it.
We check if there is a trie, corresponding to the first character of <code>word</code>.
If not, we create a trie for that character.
Now that the trie surely exists, we insert the remainder of <code>word</code> into it.
If the word has no characters, it has been fully inserted into the trie.
At that point, we set <code>wordEnd = true</code> to indicate that the word belongs to the trie (separating it from its substrings).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(string word) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (word.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        wordEnd <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(word[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(next[idx])) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// If the Trie does not exist yet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        next[idx] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Trie();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    next[idx]<span style="color:#f92672">-&gt;</span>insert(word.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="startswith"><code>startsWith</code><a hidden class="anchor" aria-hidden="true" href="#startswith">#</a></h2>
<p>The <code>startsWith</code> function is very similar to the <code>search</code> function.
The key difference is that the prefix may not have been inserted into the trie, but the path to it still exists.
The only difference between <code>search</code> and <code>startsWith</code> is thus not checking if the word is contained in the trie during the recursive base case.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">startsWith</span>(string prefix) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/* Returns `true` if there is a previously inserted word
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">       that starts with `prefix`, and `false` otherwise. */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (prefix.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> getIndex(prefix[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next[index]) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> next[index]<span style="color:#f92672">-&gt;</span>startsWith(prefix.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="full-recursive-solution">Full recursive solution<a hidden class="anchor" aria-hidden="true" href="#full-recursive-solution">#</a></h2>
<p>We provide the full recursive solution below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span> {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span> next <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">26</span>, <span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> wordEnd <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getIndex</span>(<span style="color:#66d9ef">char</span> query) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> query <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Trie() {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(string word) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (word.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            wordEnd <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(word[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(next[idx])) {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// If the Trie does not exist yet
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            next[idx] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Trie();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        next[idx]<span style="color:#f92672">-&gt;</span>insert(word.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">search</span>(string word) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (word.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> wordEnd;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> getIndex(word[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next[index]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> next[index]<span style="color:#f92672">-&gt;</span>search(word.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">startsWith</span>(string prefix) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (prefix.size() <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> getIndex(prefix[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>next[index]) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> next[index]<span style="color:#f92672">-&gt;</span>startsWith(prefix.substr(<span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="iterative-solution">Iterative solution<a hidden class="anchor" aria-hidden="true" href="#iterative-solution">#</a></h1>
<p>The recursive solution is valid, but contains two sources of avoidable overhead:</p>
<ul>
<li>For even moderately long words, we risk stack overflow and add considerable CPU overhead.</li>
<li>Recursive calls use stack memory proportional to recursion depth (word length).</li>
</ul>
<p>We can avoid recursively entering a new stack frame when inserting a new word.
Instead, we start with the root trie pointer and iteratively change it within a loop over word characters.
Staying in a single frame like this is faster and uses less space.
We modify the <code>search</code> and <code>startsWith</code> functions in a similar manner.</p>
<p>Below is the fully modified iterative solution.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Trie</span> {
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span> next <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>Trie<span style="color:#f92672">*&gt;</span>(<span style="color:#ae81ff">26</span>, <span style="color:#66d9ef">nullptr</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> wordEnd <span style="color:#f92672">=</span> false;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getIndex</span>(<span style="color:#66d9ef">char</span> query) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> query <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    Trie() {}  <span style="color:#75715e">// Class constructor
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insert</span>(string word) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Insert `word` into the trie
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Trie<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> word.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(word[i]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>next[idx]) {
</span></span><span style="display:flex;"><span>                t<span style="color:#f92672">-&gt;</span>next[idx] <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Trie();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next[idx];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        t<span style="color:#f92672">-&gt;</span>wordEnd <span style="color:#f92672">=</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">search</span>(string word) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Return true if the trie contains `word` and false otherwise
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Trie<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> word.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(word[i]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>next[idx]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next[idx];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> t<span style="color:#f92672">-&gt;</span>wordEnd;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">startsWith</span>(string prefix) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Return true if the trie contains a word that starts with `prefix`
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        Trie<span style="color:#f92672">*</span> t <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> prefix.size(); i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> idx <span style="color:#f92672">=</span> getIndex(prefix[i]);
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>t<span style="color:#f92672">-&gt;</span>next[idx]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            t <span style="color:#f92672">=</span> t<span style="color:#f92672">-&gt;</span>next[idx];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h1 id="comparison-between-recursive-and-iterative-solutions">Comparison between recursive and iterative solutions<a hidden class="anchor" aria-hidden="true" href="#comparison-between-recursive-and-iterative-solutions">#</a></h1>
<p>The actual runtime and memory consumption are indeed smaller for the iterative solution.
Leetcode reports a runtime of 90ms and 145MB of memory for the recursive, but only 19ms and 54MB of memory for the iterative solution.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://nabergoj.org/tags/data-structures/">Data Structures</a></li>
      <li><a href="https://nabergoj.org/tags/leetcode/">Leetcode</a></li>
      <li><a href="https://nabergoj.org/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
      <li><a href="https://nabergoj.org/tags/recursion/">Recursion</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://nabergoj.org/">Sunny Coding</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
